% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/THRREG.R
\name{THRREG}
\alias{THRREG}
\title{Estimate a Threshold Regression}
\usage{
THRREG(formula, ...)
}
\arguments{
\item{formula}{Model specification (see "Specials" section).}

\item{...}{Further arguments. Currently not used.}
}
\value{
A model specification.
}
\description{
Searches through the grids generated from the specified variable to identify
the threshold level with minimised sum of squared error.
Supports estimation of (constrained) single regime (a.k.a with only one threshold),
multiple regimes (searched sequentially), variable dependent regime(s) with second order polynomial
(experimental; user supplied grids required),
and nonparametric function (experimental).
}
\section{Parameterisation}{


One regime threshold regression follows the form of

\deqn{y_t = \beta_0 + \delta_0 y_{t-1} + \delta_1  y_{t-1}I(|y_{t-1}| \ge \gamma ) + controls + \epsilon_t}

Where \eqn{I} is the indicator function.
The interface of THRREG allows user to specify the model as how it is written.
\eqn{ \delta_0} (or any other coefficient) can be optionally constrained to be 1 with special \code{one}.
The indicator can be evaluated with special \code{ind}.
See "Examples" and "Specials" section.
}

\section{Specials}{


The _specials_ define the regimes that \code{THRREG} will try to find.



\subsection{one}{
The \code{one} special is used to constrain the coefficient of input variable to be 1.
When used on simple terms without indication function and threshold,
it is the same as [stats::offset()] but takes the calculation literally,
i.e. \code{-} is supported.
\preformatted{
one(arg)
}

\tabular{ll}{
  \code{arg} \tab Regressor in the regression whose coefficient is contrained to be 1 \cr
}
}

\subsection{ind and gamma}{
\code{gamma} defines the threshold location when the regimes are constant, or
the parameters that define the threshold location when the regimes depend on
other variables.
\code{ind} is used in conjunction with \code{gamma} to specify the indicator function
that seperates different regimes.
\preformatted{
gamma(id = NULL, var = NULL, grid = NULL)
}
\tabular{ll}{
  \code{id} \tab The identifier of parameter \eqn{\gamma}, namely the subscript.
  In the case of multiple constant regimes, this needs to be a numeric value
  indicating the relative position of the threshold ranked from large to small.
  For exmaple, threshold \code{gamma(1)} is above \code{gamma(2)} and so on.
  In the case of second order polynomial threshold, this needs to be a numeric value
  indicating the order of which the grid search is conducted, and the intercept in the
  polynomial should has a smaller id than the paired slope.
  For example, the threshold can be defined as \code{gamma(1) + gamma(2)*z}
  where \code{z} is the variable on which the threshold depends.\cr
  \code{var} \tab (Experimental) Variable in nonparametric estimation of the threshold. \cr
  \code{grid} \tab (Experimental) The grid of which to search for each parameter in the case of
  second order polynomial. For example \code{gamma(1, grid = 0:50) + gamma(2, grid = 0:20)*z}
  defines a threshold as a second order polynomial of variable \code{z}.
  \code{gamma(1)} can take any value in \code{0:50} and
  \code{gamma(1)} can take \code{0:20}.
  In constant regimes, the grids are the sample value of the comparing variable.  \cr
}

\preformatted{
ind(expression)
}

\tabular{ll}{
  \code{expression} \tab Input of the indicator function.
  Normally a comparison of transformation of response variable with the threshold defined by \code{gamma}.
  For example, for the one regime case this can be \code{abs(lag(y)) >= gamma(1)} \cr
}

}
\subsection{xreg}{
Exogenous regressors can be included without explicitly using the \code{xreg()} special.
Interactions and other functionality behaves similarly to [stats::lm()].
}
}

\examples{
# Simulate a time series
threshold_process <- function(lag1){
  if(abs(lag1) > 1) {
    # Above threshold of 1
    # Mean reverting
    # AR1 process with coeffcient 0.8
    lag1 * 0.8 + rnorm(1)
  } else {
    # Below threshold of 1
    # a unit root process
    lag1 + rnorm(1)
  }
}
set.seed(2222)
time_span <- 2000
y <- numeric(time_span)
for(i in 2:time_span) y[[i]] <- threshold_process(y[[i-1]])

# Convert to tsibble
library(tsibble)
df <- tsibble(y = y, idx = seq_along(y), index = idx)

# Fit the threshold regression
library(fable.thrreg)
fit <- df \%>\%
  model(thrreg = THRREG(y ~ offset(lag(y)) + lag(y)*ind(abs(lag(y)) >= gamma(1) )))
# Getting estimates
est <- tidy(fit)
est

# Estimated threshold value
.gamma_1 <- est$estimate[est$term == ".gamma_1"]
# Plot
if(requireNamespace("ggplot2")){
autoplot(df, y) +
  ggplot2::geom_hline(yintercept = c(-1, 1)) +
  ggplot2::geom_hline(yintercept = c(-.gamma_1, .gamma_1), colour = "red")
}
}
